# epp - Writeup

## Metadata
| Property | Value |
|----------|-------|
| **Name** | epp |
| **Difficulty** | ezmed |
| **Description** | Dlog in Ecc can be broken , so i fixed it |
| **Flag** | `Cybears{ELL_EXTENSION}` |

## Challenge Description
The challenge provides a Montgomery curve over a prime field $GF(p)$. The user is prompted to provide an $x$-coordinate for a generator point $G$. The server then:
1. Generates 128-bit prime scalars $S_i$ for each byte of the secret flag.
2. Computes points $P_i = S_i \cdot G$ and provides their $x$-coordinates.
3. Performs a complex point accumulation where $V$ is iteratively updated:
   $V = \text{add}(V, \text{multiply}(P_i, \text{secret}_i), |S_i \cdot \text{secret}_i - \sum_{j=0}^{i-1} S_j \cdot \text{secret}_j|)$
The `add` function is a differential addition that relies on the difference between points being a scalar multiple of $G$. The goal is to recover the flag bytes from the provided point coordinates.

## Vulnerability
The core vulnerability lies in the combination of a weak curve field and a low-density subset sum problem.

1. **Quadratic Extension Field Dlog**: The curve parameters over $GF(p)$ are not "safe" in the context of extension fields. Specifically, lifting the curve to $GF(p^2)$ yields a group order that is "smooth" (comprising many small prime factors). This makes the Discrete Logarithm Problem (DLP) solvable via the Pohlig-Hellman algorithm.
2. **Linear Accumulation Leakage**: Despite the complex differential addition, the mathematical structure simplifies to a linear combination of the primes $S_i$ and the flag bytes. Recovering $S_i$ via Dlog reveals the coefficients of a subset sum problem:
   $$\sum S_i \cdot \text{secret}_i \equiv c \pmod{\text{ord}(G)}$$
3. **Small Unknowns (Flag Bytes)**: Since each $S_i$ is 128 bits and the unknown `secret_i` is only 8 bits (ASCII), the density $d = n/B$ is extremely low, making it solvable via lattice reduction.

## Attack
1. **Dlog Recovery**: Lift the point $G$ and the points $P_i$ to $E(GF(p^2))$. Compute $S_i = \text{log}_G(P_i)$. The correct $y$-coordinate for $P_i$ is distinguished by the fact that $S_i$ must be one of the prime scalars generated by the server.
2. **Modular Target**: Compute $c = \pm \text{log}_G(V)$ to find the target of the subset sum.
3. **Lattice Reduction (LLL)**: Construct the lattice basis as implemented in the solution script:
   $$
   M = \begin{pmatrix}
   S_0 & 1 & 0 & \cdots & 0 & 0 \\
   S_1 & 0 & 1 & \cdots & 0 & 0 \\
   \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
   S_n & 0 & 0 & \cdots & 1 & 0 \\
   \text{ord}(G) & 0 & 0 & \cdots & 0 & 0 \\
   c & 0 & 0 & \cdots & 0 & R 
   \end{pmatrix}
   $$
   This corresponds to the transpose of the matrix in `sol.sage`. Running LLL on this basis finds the short vector $(\epsilon, \text{secret}_0, \text{secret}_1, \dots, \text{secret}_n, R)$ where $\epsilon = \sum S_i \cdot \text{secret}_i - c \equiv 0 \pmod{\text{ord}(G)}$.
